// This file was automatically generated by Bunli.
// You should NOT make any changes in this file as it will be overwritten.

import type { Command, CLI, GeneratedOptionMeta, RegisteredCommands, CommandOptions, GeneratedCommandMeta } from '@bunli/core'
import { createGeneratedHelpers, registerGeneratedStore } from '@bunli/core'

import Branch from '../src/commands/branch.js'
import Init from '../src/commands/init.js'
import Pr from '../src/commands/pr.js'
import Prune from '../src/commands/prune.js'
import Remove from '../src/commands/remove.js'

// Narrow list of command names to avoid typeof-cycles in types
const names = ['branch', 'init', 'pr', 'prune', 'remove'] as const
type GeneratedNames = typeof names[number]

const modules: Record<GeneratedNames, Command<any>> = {
  'branch': Branch,
  'init': Init,
  'pr': Pr,
  'prune': Prune,
  'remove': Remove
} as const

const metadata: Record<GeneratedNames, GeneratedCommandMeta> = {
  'branch': {
      name: 'branch',
      description: 'Create or switch to a worktree for a branch (default command)',
      options: {
        'from': { type: 'z.string.optional', required: false, hasDefault: false, description: 'Create branch from this branch', schema: {"type":"zod","method":"optional","args":[]}, validator: '(val) => true' }
      },
      path: '../src/commands/branch'
    },
  'init': {
      name: 'init',
      description: 'One-time setup for wt',
      path: '../src/commands/init'
    },
  'pr': {
      name: 'pr',
      description: 'Create worktree from PR (optional capability tier)',
      path: '../src/commands/pr'
    },
  'prune': {
      name: 'prune',
      description: 'Remove stale worktrees',
      options: {
        'apply': { type: 'z.boolean.default', required: true, hasDefault: true, default: false, description: 'Actually remove worktrees (default is dry-run)', schema: {"type":"zod","method":"default","args":[{"type":"unknown","raw":{"type":"BooleanLiteral","start":437,"end":442,"loc":{"start":{"line":17,"column":38,"index":437},"end":{"line":17,"column":43,"index":442}},"value":false}}]}, validator: '(val) => true' }
      },
      path: '../src/commands/prune'
    },
  'remove': {
      name: 'remove',
      description: 'Remove a worktree',
      options: {
        'branch': { type: 'z.boolean.default', required: true, hasDefault: true, default: false, description: 'Also delete the git branch', short: 'b', schema: {"type":"zod","method":"default","args":[{"type":"unknown","raw":{"type":"BooleanLiteral","start":440,"end":445,"loc":{"start":{"line":19,"column":39,"index":440},"end":{"line":19,"column":44,"index":445}},"value":false}}]}, validator: '(val) => true' },
        'force': { type: 'z.boolean.default', required: true, hasDefault: true, default: false, description: 'Force removal even if worktree is dirty', short: 'f', schema: {"type":"zod","method":"default","args":[{"type":"unknown","raw":{"type":"BooleanLiteral","start":563,"end":568,"loc":{"start":{"line":23,"column":38,"index":563},"end":{"line":23,"column":43,"index":568}},"value":false}}]}, validator: '(val) => true' }
      },
      path: '../src/commands/remove'
    }
} as const

export const generated = registerGeneratedStore(createGeneratedHelpers(modules, metadata))

export const commands = generated.commands
export const commandMeta = generated.metadata

export interface GeneratedCLI {
  register(cli?: CLI<any>): GeneratedCLI
  list(): Array<{
    name: GeneratedNames
    command: (typeof modules)[GeneratedNames]
    metadata: (typeof metadata)[GeneratedNames]
  }>
  get<Name extends GeneratedNames>(name: Name): (typeof modules)[Name]
  getMetadata<Name extends GeneratedNames>(name: Name): (typeof metadata)[Name]
  getFlags<Name extends keyof RegisteredCommands & string>(name: Name): CommandOptions<Name>
  getFlagsMeta<Name extends GeneratedNames>(name: Name): Record<string, GeneratedOptionMeta>
  withCLI(cli: CLI<any>): { execute(name: string, options: unknown): Promise<void> }
}

export const cli: GeneratedCLI = {
  register: (cliInstance?: CLI<any>) => { generated.register(cliInstance); return cli },
  list: () => generated.list(),
  get: <Name extends GeneratedNames>(name: Name) => generated.get(name),
  getMetadata: <Name extends GeneratedNames>(name: Name) => generated.getMetadata(name),
  getFlags: <Name extends keyof RegisteredCommands & string>(name: Name) => generated.getFlags(name) as CommandOptions<Name>,
  getFlagsMeta: <Name extends GeneratedNames>(name: Name) => generated.getFlagsMeta(name),
  withCLI: (cliInstance) => generated.withCLI(cliInstance)
}

// Enhanced helper functions
export const listCommands = () => generated.list().map(c => c.name)
export const getCommandApi = <Name extends GeneratedNames>(name: Name) => generated.getMetadata(name)
export const getTypedFlags = <Name extends GeneratedNames>(name: Name) => generated.getFlags(name) as CommandOptions<Name>
export const validateCommand = <Name extends GeneratedNames>(name: Name, flags: Record<string, unknown>) => generated.validateCommand(name, flags)
export const findCommandByName = <Name extends GeneratedNames>(name: Name) => generated.findByName(name)
export const findCommandsByDescription = (searchTerm: string) => generated.findByDescription(searchTerm)
export const getCommandNames = () => generated.getCommandNames()

// Auto-register on import for zero-config usage
export default cli

// Ensure module augmentation happens on import
declare module '@bunli/core' {
  // Precise key mapping without typeof cycles
  interface RegisteredCommands extends Record<GeneratedNames, Command<any>> {}
}
